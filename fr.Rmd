---
title: "fo"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

fill_dots_helper <- function(var_names, .) {
  index <- which(var_names == ".")
  if(length(index)==0){
    
    return(sort(var_names))
  }
  len <- length(index)
  index <- min(which(var_names == "."))
  all_items <- lapply(., function(var) {
    new_var_names <- var_names
    new_var_names[index] <- var
    out <- fill_dots_helper(new_var_names, .)
    
    if(is.list(out[[1]])) {
      out <- unlist(out, recursive = FALSE)
    }
    return(out)
  })
  
  
  return(unique(all_items)) 
}
fill_dots <- function(var_names, .) {
  x <- unique(unlist(fill_dots_helper(var_names, . = .), recursive = F) )
  keep <- sapply(x, function(item) {
    if(any(duplicated(item))) {
      return(FALSE)
    }
    return(TRUE)
  })
  return(x[keep])
}
x <-  fill_dots(c("W1"   ), . = c("W1", "W2", "W3", "W4", "W5", "W6")) 

print("hi")
x
length(x)
dim(combn(6,2))
```


```{r}
str <- "h(x,y,z) "
str <- str_match_all(str,"[,(]([^()]+)[,)]")[[1]][,-1]
str_split(str, ",")[[1]]
```


```{r}
rm(`+`)

setMethod("+",
          c(e1 = "hal9001_formula", e2 = "hal9001_formula"),
          function(e1, e2) {
            x[[1]] + y[[1]]
          }
)

item <- list(x=1)
class(item) <- "hal9001+formula"
`+.formula_hal9001` <- function(x, y) {
  list(
    basis = c(x$basis, y$basis),
    penalty.factors  = c(x$penalty.factors, y$penalty.factors),
     lower.limits= c(x$lower.limits, y$lower.limits),
     upper.limits = c(x$upper.limits, y$upper.limits))
  
}
 
item + item   

```

```{r}
h(A, k = 3, s = 0) + h(W1,A, k=1, s=1) + h(W1,A, k=1, s=1)

```


```{r}
library(hal9001)
library(stringr)
`+.formula_hal9001` <- function(x, y) {
  list(
    basis = c(x$basis, y$basis),
    penalty.factors  = c(x$penalty.factors, y$penalty.factors),
     lower.limits= c(x$lower.limits, y$lower.limits),
     upper.limits = c(x$upper.limits, y$upper.limits))
  
}

h <- function(...,  k = 3 , s = 1, pf = 1, monotone = c("none", "i", "d"), . = NULL , dot_args_as_string = FALSE) {
  monotone <- match.arg(monotone)
  X <- as.matrix(get("X")) # Get design matrix from parent environment
  if(is.null(.)) {
    . <- colnames(X)
  }
  
  if(!dot_args_as_string) {
    str <- (deparse(substitute(c(...)))) # Extract names of possibly nonexisting environment variables (e.g. like formula) 
    str <- stringr::str_replace_all(str, " ", "")
    str <- str_match_all(str,"[,(]([^()]+)[,)]")[[1]][,-1]
    var_names <- str_split(str, ",")[[1]]
    # print(str)
    # var_names <- str_match_all(str,"[,(]([^(,]+)[,)]")[[1]][,-1]
    # print( str_match(str,"[,(]([^(,]+)[,)]"))
    #   print( str_match_all(str,"[,]([^(,]+)[,]"))
    # var_names <- c(var_names,str_match_all(str,"[,]([^(,]+)[,]")[[1]][,-1])
    var_names <- stringr::str_replace_all(var_names, " ", "")
  } else {
    var_names <- unlist(list(...))
  }
  
  if("." %in% var_names) {
    var_names_filled <- fill_dots(var_names, . = .)
    all_items <- lapply(var_names_filled, function(var) {
      h(var,  k = k , s = s,  pf = pf, monotone = monotone, . = ., dot_args_as_string = TRUE)
    })
    basis_all <- unlist(lapply(all_items, function(item) {
      item$basis
    }), recursive = F)
    penalty.factors_all <- unlist(lapply(all_items, function(item) {
      item$penalty.factors
    }))
    lower.limits_all <- unlist(lapply(all_items, function(item) {
      item$lower.limits
    }))
    upper.limits_all <- unlist(lapply(all_items, function(item) {
      item$upper.limits 
    }))
    all_items <- list(basis = basis_all,  penalty.factors = penalty.factors_all, lower.limits = lower.limits_all, upper.limits = upper.limits_all)
    class(all_items) <- "formula_hal9001"
    return(all_items)
  }
  col_index <- match(var_names, colnames(X)) # Get corresponding column indices
  lapply(seq_along(col_index), function(i){
    var <- var_names[i]
    j <- col_index[i]
    
    if(!(length(k) == 1)) {
      tryCatch({
        
        if(var %in% names(k)) {
          k <- unlist(k[var])
        } else {
          k <- unlist(k["."])
        }
        
        print(k)
      }, error = function(){
        stop("k must be a variable named list or vector.")
      })
    } 
    x <- X[,j]
    bins <- quantile(x, seq(0,1, length.out = k+1))
    x <- bins[findInterval(x, bins, all.inside = TRUE)]
    X[,j] <<- x
  })
  
  
  basis_list_item <- hal9001:::make_basis_list(X[,col_index, drop = F], col_index,  rep(s,  ncol(X)) )
  penalty.factors <- rep(pf,length(basis_list_item)) 
  if(monotone == "i"){
    lower.limits <- rep(0,length(basis_list_item)) 
    upper.limits <- rep(Inf,length(basis_list_item)) 
  } else if(monotone == "d"){
    lower.limits <- rep(-Inf,length(basis_list_item)) 
    upper.limits <- rep(0,length(basis_list_item)) 
  } else {
    lower.limits <- rep(-Inf,length(basis_list_item)) 
    upper.limits <- rep(Inf,length(basis_list_item)) 
  }
  out <- list(basis = basis_list_item, penalty.factors = penalty.factors, lower.limits = lower.limits, upper.limits = upper.limits)
  class(out) <- "formula_hal9001"
  return(out)
}

```

```{r}
form <- "~ h(.,., k = list( W2= 5, .=1))  "
form <- stringr::str_replace_all(form, " ", "")
interactions <- stringr::str_match_all(
  form, "(h\\([^\\s+]+\\))"
)[[1]][,2]

all_info <- lapply(interactions, function(expr) {
  eval(parse(text=expr))
})
basis_all <- unlist(lapply(all_info, function(item) {
  item$basis
}), recursive = F)
penalty.factors_all <- unlist(lapply(all_info, function(item) {
  item$penalty.factors
}))
lower.limits_all <- unlist(lapply(all_info, function(item) {
  item$lower.limits
}))
upper.limits_all <- unlist(lapply(all_info, function(item) {
  item$upper.limits 
}))
basis_all

```